{
  "author_id": "Helen Yu",
  "author_url": "https://edabit.com/user/mNMQvcxKSSvqqMYCH",
  "challenge_id": "ogDHjfpAcE896kN4H",
  "code": "function canExit(arr) {\n  \n}",
  "difficulty": "Expert",
  "instructions": "<p><span>A maze can be represented by a 2D matrix, where </span><code>0</code><span>s represent </span><strong><span>walkeable</span></strong><span> areas, and </span><code>1</code><span>s represent walls. You start on the upper left corner and the exit is on the most lower right cell.</span></p><p><span>Create a function that returns </span><code>true</code><span> if you can walk from one end of the maze to the other. You can only move up, down, left and right. You </span><strong><span>cannot move diagonally</span></strong><span>.</span></p><h3><span>Examples</span></h3><pre><code>canExit([\n  [0, 1, 1, 1, 1, 1, 1],\n  [0, 0, 1, 1, 0, 1, 1],\n  [1, 0, 0, 0, 0, 1, 1],\n  [1, 1, 1, 1, 0, 0, 1],\n  [1, 1, 1, 1, 1, 0, 0]\n]) \u279e true\n\ncanExit([\n  [0, 1, 1, 1, 1, 1, 1],\n  [0, 0, 1, 0, 0, 1, 1],\n  [1, 0, 0, 0, 0, 1, 1],\n  [1, 1, 0, 1, 0, 0, 1],\n  [1, 1, 0, 0, 1, 1, 1]\n]) \u279e false\n\n// This maze only has dead ends!\n\ncanExit([\n  [0, 1, 1, 1, 1, 0, 0],\n  [0, 0, 0, 0, 1, 0, 0],\n  [1, 1, 1, 0, 0, 0, 0],\n  [1, 1, 1, 1, 1, 1, 0],\n  [1, 1, 1, 1, 1, 1, 1]\n]) \u279e false\n\n// Exit only one block away, but unreachable!\n\ncanExit([\n  [0, 1, 1, 1, 1, 0, 0],\n  [0, 0, 0, 0, 1, 0, 0],\n  [1, 1, 1, 0, 0, 0, 0],\n  [1, 0, 0, 0, 1, 1, 0],\n  [1, 1, 1, 1, 1, 1, 0]\n]) \u279e true</code></pre><h3><span>Notes</span></h3><ul><li><span>In a maze of size </span><code>m x n</code><span>, you enter at </span><code>[0, 0]</code><span> and exit at </span><code>[m-1, n-1]</code><span>.</span></li><li><span>There can be dead ends in a maze - one exit path is sufficient.</span></li></ul>",
  "source_url": "https://edabit.com/challenge/ogDHjfpAcE896kN4H",
  "tags": [
    "arrays",
    "functional_programming",
    "games",
    "higher_order_functions"
  ],
  "tests": "Test.assertEquals(canExit([\n\t[0, 1, 1, 1, 1, 1, 1], \n\t[0, 0, 1, 1, 0, 1, 1], \n\t[1, 0, 0, 0, 0, 1, 1], \n\t[1, 1, 1, 1, 0, 0, 1], \n\t[1, 1, 1, 1, 1, 0, 0]\n]), true)\n\nTest.assertEquals(canExit([\n\t[0, 1, 1, 1, 1, 1, 1], \n\t[0, 0, 1, 0, 0, 1, 1], \n\t[1, 0, 0, 0, 0, 1, 1], \n\t[1, 1, 0, 1, 0, 0, 1], \n\t[1, 1, 0, 0, 1, 1, 1]\n]), false)\n\nTest.assertEquals(canExit([\n\t[0, 1, 1, 1, 1, 0, 0], \n\t[0, 0, 0, 0, 1, 0, 0], \n\t[1, 1, 1, 0, 0, 0, 0], \n\t[1, 1, 1, 1, 1, 1, 0], \n\t[1, 1, 1, 1, 1, 1, 1]\n]), false)\n\nTest.assertEquals(canExit([\n\t[0, 1, 1, 1, 1, 0, 0], \n\t[0, 0, 0, 0, 1, 0, 0], \n\t[1, 1, 1, 0, 0, 0, 0], \n\t[1, 0, 0, 0, 1, 1, 0], \n\t[1, 1, 1, 1, 1, 1, 0]\n]), true)\n\nTest.assertEquals(canExit([\n\t[0, 1, 1, 1, 1, 0, 0], \n\t[0, 0, 0, 0, 1, 0, 0], \n\t[1, 1, 1, 0, 0, 0, 0], \n\t[1, 0, 0, 0, 0, 1, 1], \n\t[1, 1, 1, 1, 0, 0, 0]\n]), true)\n\nTest.assertEquals(canExit([\n\t[0, 1, 1, 1, 1, 0, 1], \n\t[0, 0, 0, 0, 1, 0, 1], \n\t[1, 1, 1, 0, 0, 0, 1], \n\t[1, 0, 0, 0, 0, 1, 1], \n\t[1, 1, 1, 1, 0, 1, 1]\n]), false)\n\nTest.assertEquals(canExit([\n\t[0, 0, 0, 0, 0, 0, 0], \n\t[0, 0, 0, 0, 1, 0, 0], \n\t[1, 1, 1, 0, 0, 0, 0], \n\t[1, 0, 0, 0, 0, 1, 0], \n\t[1, 1, 1, 1, 0, 1, 0]\n]), true)\n\nTest.assertEquals(canExit([\n\t[0, 0, 0, 0, 0, 0, 0], \n\t[0, 1, 1, 1, 1, 1, 0], \n\t[0, 1, 1, 1, 1, 1, 0], \n\t[0, 1, 1, 1, 1, 1, 0], \n\t[0, 0, 0, 0, 0, 0, 1]\n]), false)\n\nTest.assertEquals(canExit([\n\t[0, 0, 1, 1, 1, 1, 1], \n\t[1, 0, 0, 1, 1, 1, 1], \n\t[1, 1, 0, 0, 1, 1, 1], \n\t[1, 1, 1, 0, 0, 0, 0], \n\t[1, 1, 1, 1, 1, 1, 0]\n]), true)\n\n// More False Tests\nTest.assertEquals(canExit([\n\t[0, 0, 0, 0, 0, 0, 0], \n\t[0, 1, 1, 1, 1, 1, 0], \n\t[0, 1, 1, 1, 1, 1, 0], \n\t[0, 1, 1, 1, 1, 1, 1], \n\t[0, 0, 0, 0, 0, 1, 0]\n]), false)\n\nTest.assertEquals(canExit([\n\t[0, 1, 0, 0, 0, 0, 0], \n\t[0, 1, 1, 1, 1, 1, 0], \n\t[0, 1, 1, 1, 1, 1, 0], \n\t[0, 1, 1, 1, 1, 1, 0], \n\t[0, 0, 0, 0, 0, 1, 0]\n]), false)",
  "title": "Can You Exit the Maze?"
}