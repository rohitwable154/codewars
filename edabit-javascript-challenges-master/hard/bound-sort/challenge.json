{
  "author_id": "Helen Yu",
  "author_url": "https://edabit.com/user/mNMQvcxKSSvqqMYCH",
  "challenge_id": "riBaZGcbdEwBKmqzr",
  "code": "function boundSort(arr, bounds) {\n  \n}",
  "difficulty": "Hard",
  "instructions": "<p><span>Create a function that returns </span><code>true</code><span> an input array can be completely sorted by only sorting within the bounds </span><code>[0, n]</code><span> (inclusive), where </span><code>n</code><span> is smaller than or equal to the array's length, and </span><code>false</code><span> otherwise.</span></p><h3><span>Examples</span></h3><pre><code>boundSort([1, 6, 5, 3, 8, 9], [0, 3]) \u279e true\n// If [1, 6, 5, 3] is sorted to [1, 3, 5, 6], the array is completely sorted.\n\nboundSort([1, 6, 5, 3, 8, 9], [0, 2]) \u279e false\n// Even if [1, 6, 5] is sorted to [1, 5, 6], the array is still not completely sorted.\n\nboundSort([1, 9, 2, 5, 7], [0, 4]) \u279e true\n\nboundSort([1, 9, 2, 5, 7], [0, 3]) \u279e false\n// Sorting from [0, 3] gives us [1, 2, 5, 9, 7], array still not completely sorted.</code></pre><h3><span>Notes</span></h3><ul><li><span>Numbers in array will be unique.</span></li><li><span>The lower index of the bound will always be </span><code>0</code><span>.</span></li></ul>",
  "source_url": "https://edabit.com/challenge/riBaZGcbdEwBKmqzr",
  "tags": [
    "arrays",
    "sorting",
    "validation"
  ],
  "tests": "Test.assertEquals(boundSort([1, 6, 5, 3, 8, 9], [0, 3]), true)\nTest.assertEquals(boundSort([1, 6, 5, 3, 8, 9], [0, 2]), false)\nTest.assertEquals(boundSort([1, 9, 2, 5, 7], [0, 4]), true)\nTest.assertEquals(boundSort([1, 9, 2, 5, 7], [0, 3]), false)\nTest.assertEquals(boundSort([1, 2, 3, 4, 5, 8, 9], [0, 1]), true)\nTest.assertEquals(boundSort([1, 2, 3, 5, 4, 8, 9], [0, 4]), true)\nTest.assertEquals(boundSort([1, 2, 3, 5, 4, 8, 9], [0, 3]), false)",
  "title": "Bound Sort"
}