{
  "author_id": "Helen Yu",
  "author_url": "https://edabit.com/user/mNMQvcxKSSvqqMYCH",
  "challenge_id": "tQNGydfWqZueRgmDC",
  "code": "function canPatch(bridge, planks) {\n  \n}",
  "difficulty": "Hard",
  "instructions": "<p><span>A broken bridge can be represented by </span><code>1</code><span>s and </span><code>0</code><span>s, where contiguous </span><code>0</code><span>s represent holes. You can walk across a bridge with a hole with a maximum width of 1, but any holes bigger than that you must fix first. For example, the bridge below is walkeable:</span></p><pre><code>[1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1]</code></pre><p><span>This bridge is not:</span></p><pre><code>[1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</code></pre><p><span>You own several wooden planks, each with different widths. You can patch the holes on the bridge with these planks. More specifically, a plank size </span><code>n</code><span> can fill a </span><code>n</code><span>-sized hole. If you had a plank of size </span><code>2</code><span>, the un-walkeable bridge above could be filled in:</span></p><pre><code>[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</code></pre><p><span>But even if you only had a plank of size </span><code>1</code><span>, you could still transform the unwalkeable bridge into a walkeable one:</span></p><pre><code>[1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]</code></pre><p><span>Write a function that takes in a broken bridge, an array of plank sizes, and returns </span><code>true</code><span> if the bridge can be patched up enough to walk over, and </span><code>false</code><span> otherwise.</span></p><h3><span>Examples</span></h3><pre><code>canPatch([1, 0, 0, 0, 0, 0, 0, 1], [5, 1, 2]) \u279e true\n// You can use the 5 plank to transform the 6 hole to a 1 hole.\n// Leftover planks [1, 2] are okay.\n\ncanPatch([1, 0, 0, 0, 0, 0, 0, 1], [4, 1, 2, 3, 4]) \u279e false\n// None of your planks are long enough (you can't combine them).\n\ncanPatch([1, 0, 0, 1, 1, 0, 0, 0, 1], [1, 2]) \u279e true\n\ncanPatch([1, 0, 0, 1, 1, 0, 0, 0, 1], [1, 1]) \u279e false</code></pre><h3><span>Notes</span></h3><ul><li><span>Individual planks may NOT be combined to form a longer plank.</span></li><li><span>Leftover planks are okay.</span></li></ul>",
  "source_url": "https://edabit.com/challenge/tQNGydfWqZueRgmDC",
  "tags": [
    "arrays",
    "higher_order_functions",
    "validation"
  ],
  "tests": "Test.assertEquals(canPatch([1, 0, 0, 1], [1]), true)\nTest.assertEquals(canPatch([1, 0, 0, 1], [1, 2]), true)\nTest.assertEquals(canPatch([1, 0, 0, 1], []), false)\nTest.assertEquals(canPatch([1, 0, 1, 1], []), true)\nTest.assertEquals(canPatch([1, 0, 1, 0, 1, 0, 1, 0, 1], []), true)\nTest.assertEquals(canPatch([1, 0, 0, 0, 0, 0, 0, 1], [5, 1, 2]), true)\nTest.assertEquals(canPatch([1, 0, 0, 0, 0, 0, 0, 1], [4, 1, 2, 3, 4]), false)\nTest.assertEquals(canPatch([1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 1]), false)\nTest.assertEquals(canPatch([1, 0, 0, 1, 0, 0, 1, 0, 0, 1], [1, 1, 1]), true)\nTest.assertEquals(canPatch([1, 0, 0, 1, 1, 0, 0, 0, 1], [1, 2]), true)\nTest.assertEquals(canPatch([1, 0, 0, 1, 1, 0, 0, 0, 1], [1, 1]), false)\nTest.assertEquals(canPatch([1, 0, 0, 1, 1, 1, 0, 0, 1], [1, 1]), true)\nTest.assertEquals(canPatch([1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 3, 1]), true)\nTest.assertEquals(canPatch([1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 3, 1, 5, 5]), true)\nTest.assertEquals(canPatch([1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1], [1, 2, 2]), false)",
  "title": "Broken Bridge"
}